
# Just to be clear, this python code is mostly here to structure data as jsons for eww. eww itself will then use that data and send commands to mpd using mpc.
# As such, all entries must have both the displayed text and the mpc info
# This is mostly to list a few things :
# a) Library
# b) Playlists
# c) Current playlist - Note : mpd has renamed it to queue. mpd docs recommend using songids, but mpc can only use song positions. eww should update quick enough to not cause a problem, but that can only be garentied in a localhost connection
# d) mpd status
# Additionally, we want to replace the current mpd scripts, as mpc does not support song ids. I would rather not continiously query mpd, but at the same time...
# Unfortunately, this will cause a few issues.
# 1) mpd will not accept any commands from an idle connection. As such, we need to interpolate the data
# 2) mpd will not accept any commands from an idle connection. As such, we need to be able to stop idling while we deal with commands. This is easy for the stuff that waits the idle to check if something changed, but will be harder for eww buttons
# 3) We are going to have to port the named pipe thingy from the custom notification server. This also means handling the fact we are going to be multithreaded

# This is essentially a background service that will keep calling `eww update` when MPDClient.idle gets an update. 

# We are using python-mpd2
from mpd import MPDClient
import re

client = MPDClient()
client.timeout = 10
client.idletimeout = None
client.connect("localhost",6600) # TODO : Maybe add this as a command line argument?


# yeah we are doing this again...
pipe_input_file = pipe_dir + "/eww_mpd_helper-input"


def convert_bool_int(bool_or_int) :
    if (isinstance(bool_or_int,bool)) :
        return 1 if bool_or_int else 0
    
    if (not isinstance(bool_or_int,(int,float))) :
        raise TypeError

    return False if bool_or_int == 0 else True



def update_eww(variable_name,content) :
    print(content)



def _song_displayname(song) :
    displayname_str = ""
    if "title" in song :
        if "artist" in song :
            displayname_str = song["artist"] + " - "
        displaynamestr = displayname_str + song["title"]
        return displaynamestr
    return re.sub(r"(\[[A-z0-9]+\])*\.mp3$","",song["file"])


# Because we are going to send this over to eww, and we kinda want to reduce the amount of logic eww does, ya know....
def song_repackage(song) :
    return {
            "file"          : song["file"],
            "id"            : song["id"],
            "duration"      : song["duration"],
            "displayname"   : _song_displayname(song),
            }

# List of subsystems :
# V database - The song database has been modified after update
# X update - a database update has started of finished.
# V stored_playlist - A stored playlist has been modified, created, renamed or deleted
# V playlist - The queue has been modified
# V player - The player has been started, stopped or seeked (or tags have changed). This will also trigger when the song just automatically changes at the end of the previous song
# V mixer - The volume has been changed
# X output -- An audio output has been added, removed or modified. Not useful right now
# V options - options like repeat, random, crossfade, replay gain, etc
# X partition - This allows to have a multi-player mpd server. However, mpc does not support this, so neither should we
# X sticker - Pieces of informations attached to song that can be generated by any client. Not useful to us right now
# X subscription - this allows for multiple clients communicate with each other using mpd. mpc does support it (mpc channels | mpc send_message <channel> <message> | mpc waitmessage <channel> | mpc subscribe <channel> ) Could be an interesting way to have communications between eww and this
# X message - We received a message on a subscribed channel. It says that this event is only emitted when the queue is empty


# Meant to be called by mixer and options
# Also updates the song
def update_status() :
    update_eww("mpdstatus",client.status())

# Note : This should also sync up the local values of elapsed time and stuff
def update_player() :
    update_eww("mpdcurrent",song_repackage(client.currentsong()))

def subsystem_match(subsystem) :
    print(subsystem)
    match subsystem:
        case "database":
            print("not implemented")
            return
        case "stored_playlist":
            print("not implemented")
            return
        case "playlist":
            print("not implemented")
            return
        case "player":
            update_player()
            return
        case "mixer": # Due to missing stuff, both mixer and options will essentially run the same thing
            update_status()
            return
        case "options":
            update_status()
            return


def idle_start() :
    subsystems = client.idle("database","stored_playlist","playlist","player","mixer","options")
    for subsystem in subsystems :
        subsystem_match(subsystem)


#lolxd = client.search("file","")
#for item in lolxd :
#    print(item)
idle_start()
client.close()
client.disconnect()
